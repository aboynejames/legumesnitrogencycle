/**
* Dsensor Ethereum API
*
*  using ethereum.org javascript API
* @class ethereurmjsAPI
*
* @package    dsensor.org  open source project
* @copyright  Copyright (c) 2015 James Littlejohn
* @license    http://ww
* @version    $Id$
*/
var util = require('util');
var events = require("events");
var Web3 = require('web3');
var fs = require('fs');


var ethereurmjsAPI = function(influxIN, DsprotocolIN, DMcomputeIN) {

  this.publicaccount = '';
  this.samplingprotocol = DsprotocolIN;
  this.dmcomputeprotocol = DMcomputeIN;
  events.EventEmitter.call(this);
  this.web3 = new Web3();
//console.log(web3);
  this.web3.setProvider(new this.web3.providers.HttpProvider('http://localhost:8552'));
  this.liveInflux = influxIN;
  this.publicaccount = '';
	this.livecontractslist = [];
  this.livestoragelist = [];
	this.livesensorlist = [];
  this.livedmaplist = [];
  this.livesamplinglist = [];
	this.abisensor = '';

	this.abi = '';

};

/**
* inherits core emitter class within this class
* @method
*/
util.inherits(ethereurmjsAPI, events.EventEmitter);

/**
*  check status of ethereum
* @method checkEthereum
*
*/
ethereurmjsAPI.prototype.checkEthereum = function() {

	var version = Web3.version.api;
	var versionc = Web3.version.client;

};

/**
*  listen for compute feedback
* @method listenCompute
*
*/
ethereurmjsAPI.prototype.listenCompute = function() {

  this.dmcomputeprotocol.on("peer-score-complete", function(compuInfo) {

    this.recallDmapContract("record-scoring", compuInfo.scid, 0, 0, 0, compuInfo.pvalue);

  });

};

/**
*  MPPM list
* @method listMPPMContracts
* @return {array} list of smart contracts MPPM
*
*/
ethereurmjsAPI.prototype.listMPPMContracts = function() {

	var MPPMplist = [];
	MPPMplist = [112233];

	return MPPMplist;

};

/**
*  sensor list
* @method listSensorContracts
* @return {array} list of smart contracts sensors
*
*/
ethereurmjsAPI.prototype.listSensorContracts = function() {

	var sensorlist = [];
	sensorlist = [112233];

	return sensorlist;

};

/**
*  set ethereum public key
* @method checkAccounts
*
*
*/
ethereurmjsAPI.prototype.setPublickey = function(epubkey) {

  this.publicaccount = epubkey;
	this.web3.eth.defaultAccount = epubkey;
	this.checkAccounts();
};

/**
*  Check basic account details
* @method checkAccounts
*
*
*/
ethereurmjsAPI.prototype.checkAccounts = function() {
	// let's assume that coinbase is our account
//console.log(web3.eth.coinbase);
  var balether = this.web3.fromWei(this.web3.eth.getBalance(this.publicaccount), "ether")
console.log(balether + 'ether in account');
	var gasPrice = this.web3.eth.gasPrice;
console.log(gasPrice.toString(10));

};

/**
*  Send ether to another account
* @method etherSendtransaction
*
*
*/
ethereurmjsAPI.prototype.etherSendtransaction = function(receipient, value) {

	Web3.eth.sendTransaction({to: receipient, value: value}, function(err, address) {
	  if (!err)
	  {
console.log(address);

	  }
	  else
	  {
console.log(err);
	  }

	});

};

/**
*   read a file
* @method readSolidityfile
*
*
*/
ethereurmjsAPI.prototype.readSolidityfile = function(nameContract) {

  var filepath = 'smartcontracts/' + nameContract + '.sol';
  var contractdata = fs.readFileSync(filepath);
//console.log('data from solidity file');;
  return contractdata;
};

/**
*   create a permission  contract
* @method createPermissions
*
*
*/
ethereurmjsAPI.prototype.createPermissions = function() {

  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('permissions-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 2500000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract
        localthis.livesensorlist.push(myContract.address);

      }
    });

};

/**
*   create a new Smart Contract
* @method createSensorcontract
*
*
*/
ethereurmjsAPI.prototype.createSensorcontract = function(infoIN) {

  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('sensor-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 2500000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract
        myContract.setSensorOwner();
        myContract.setSensorBrand(infoIN.info.devicename);
        myContract.setSensorFirmware(infoIN.info.FWid);
        // for each sensor on device match to data model (needs owns smart contract TODO)
        myContract.setSensorMeasure('IRtemperature', 'temperature', 'celcius');
        localthis.livesensorlist.push(myContract.address);
        // update client UI with ID of dmap
        var clientData = {};
        clientData.scid = myContract.address;
        clientData.info = infoIN.info;
        localthis.emit("newSensor-contract-id", clientData);
        //create linked storage API contract
        localthis.createStoragecontract(myContract.address);

      }

    });

};

/**
*   create storage Access contract
* @method createStoragecontract
*
*
*/
ethereurmjsAPI.prototype.createStoragecontract = function(sensorContract) {
console.log('create storage api contract');
  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('storageapi-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 2500000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract each storage contract is associated with a sensor smart contract
        myContract.setSensorAddress(sensorContract);

        // call the sensor contract and add storage contract ID (could call instance from sensor contract but keep simeple for now)
        var smartCdata = {};
        smartCdata.scid = sensorContract;
        smartCdata.storageCID = myContract.address;
        localthis.recallSensorContract("set-storage-contract", smartCdata);

        // update client UI with ID of storage contract
        var databack = {};
        databack.sensorscid = sensorContract;
        databack.storagescid = myContract.address;
        localthis.emit("newStorage-contract-id", databack);

      }
    });

};

/**
*   create a new Dmap contract
* @method createDmapcontract
*
*
*/
ethereurmjsAPI.prototype.createDmapcontract = function(action, infoIN) {

  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('dmap-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
  var blockwatch = this.web3.eth.filter('latest');

    this.web3.eth.contract(abi).new({data: code, gas: 2500000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);

        // auto Dsensor sampling or Researcher Invite?
        if(action == "dmap-add")
        {
          // prepare string max lenghts for solidty limits
          str1 = infoIN.gitrepo.slice(0,24);
          str2 = infoIN.gitrepo.slice(24,48);
          str3 = infoIN.gitrepo.slice(48,62);
          strh1 = infoIN.githash.slice(0,24);
          strh2 = infoIN.githash.slice(24,48);
          // call the contract and put the standard dmap form details common to both types
          myContract.setMappingDetail(infoIN.dmaprname, infoIN.description);
          myContract.setMappingDetailcodeurl(str1, str2, str3);
          myContract.setMappingDetailcodehash(strh1, strh2);;
          myContract.setDataModel('0x52bddcd1897e2b7516b2218e69fda38c017c29b9');
          //myContract.setDscoring(123, 456);

          // update client UI with ID of dmap
          var clientDmapInfo = {};
          clientDmapInfo.scid = myContract.address;
          clientDmapInfo.info = infoIN;
          localthis.emit("newDsample-contract-id", clientDmapInfo);

          // now with both dmap ID and Sampling ID(from within dmap contract)  make a hope  (that peer with then interact with ID of contracts)
          localthis.samplingprotocol.startSampling(myContract.address);

        }
        else if(action == "dmap-add-research")
        {
          // prepare string max lenghts for solidty limits
          str1 = infoIN.gitrepo.slice(0,24);
          str2 = infoIN.gitrepo.slice(24,48);
          str3 = infoIN.gitrepo.slice(48,62);
          strh1 = infoIN.githash.slice(0,24);
          strh2 = infoIN.githash.slice(24,48);
          // call the contract and put the standard dmap form details common to both types
          myContract.setMappingDetail(infoIN.dmaprname, infoIN.description);
          myContract.setMappingDetailcodeurl(str1, str2, str3);
          myContract.setMappingDetailcodehash(strh1, strh2);;
          myContract.setDataModel('0x52bddcd1897e2b7516b2218e69fda38c017c29b9');
          //myContract.setDscoring(123, 456);

          // update client UI with ID of dmap
          var clientDmapInfo = {};
          clientDmapInfo.scid = myContract.address;
          clientDmapInfo.info = infoIN;
          localthis.emit("newDresearch-contract-id", clientDmapInfo);

        }


      }
    });

};

/**
*    manages smart contract compute environment
* @method createCPUapicontract
*
*
*/
ethereurmjsAPI.prototype.createComputecontract = function(action, infoIN) {

  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('cpuapi-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
  var blockwatch = this.web3.eth.filter('latest');

    this.web3.eth.contract(abi).new({data: code, gas: 2500000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);

        // auto Dsensor sampling or Researcher Invite?
        if(action == "setup-start-cpu")
        {

            myContract.setComputeStart(infoIN);
            // tell the Dmap contract the cpu smart contract ref.
            localthis.recallDmapContract('cpu-contract-address', infoIN, myContract.address);
        }

      }

    });

};

/**
*   recall data from a smartcontract
* @method recallSensorContract
*
*
*/
ethereurmjsAPI.prototype.recallSensorContract = function(action, smcontractIN) {

  var contractdata = this.readSolidityfile('sensor-contract');

  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
	var myContract = this.web3.eth.contract(abi);
	var myContractSet = myContract.at(smcontractIN.scid);
//console.log(mysamplingContract);


  // what action to perform on smart contract
  if(action == "set-storage-contract")
  {
    //
    myContractSet.setStorageContract(smcontractIN.storageCID);
    // tell UI smart contract was updated successfully

  }
  else if(action == "get-sensor-details")
  {
    // call the contract to return data
    var returnName = myContract.getBrand();
    var returnOwner = myContract.getOwner();
    var returnMeasure = myContract.getMeasure();

  }

};

/**
*   check permission and token
* @method recallStorageContract
*
*
*/
ethereurmjsAPI.prototype.recallStorageContract = function(action, smcontractIN) {
console.log('recall storage contract');
console.log(smcontractIN);
  var localthis = this;
  var contractdata = this.readSolidityfile('storageapi-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(smcontractIN.scid);

  // what action to perform on smart contract
  if(action == "set-storage-ID")
  {
    //
    mysamplingContract.setSensorAddress(smcontractIN.scid);

  }
  else if(action == "set-permission")
  {
    // need to input list of permission askers
    var permapi = smcontractIN.plevel;
    mysamplingContract.setPermission(permapi);
    // send message to peer with contract ID
    var sendDHTmessage = {};
    sendDHTmessage.type = 'sendPermission';
    var buildtext = {};
    buildtext.pubethk = smcontractIN.pubethk;
    buildtext.scid = smcontractIN.scid;
    sendDHTmessage.text = buildtext;
    // need to serialse object
    var serialsendMessage = JSON.stringify(sendDHTmessage);
    localthis.emit("permision-notify", serialsendMessage);

  }
  else if(action == "set-token")
  {
    // encrypt token
    mysamplingContract.setToken(smcontractIN.safetoken);

  }
  else if(action == "get-token")
  {
    // encrypt token
    mysamplingContract.getToken();

  }

  else if (action == "get-permission-status")
  {
console.log('permission asker status');
console.log(smcontractIN);
    var returnpermission = mysamplingContract.getPermissionLevel();
console.log('Token permission =====');
console.log(returnpermission);
console.log(returnpermission.toString(10));

  }
  else if (action == "get-permission-history")
  {
      var pHistorydata = {};
      pHistorydata.scid = smcontractIN.scid;

      var phisoryList = mysamplingContract.getHistoryPermGranted();
      pHistorydata.list = phisoryList;
      localthis.emit("return-storperm-history", pHistorydata);

  }

};

/**
*   recall data from a Dmap contract
* @method recallDmapContract
*
*
*/
ethereurmjsAPI.prototype.recallDmapContract = function(action, contractID, computeid, pubkeyeth, ppath, score) {

  var localthis = this;
  var contractdata = this.readSolidityfile('dmap-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(contractID);

  // what action required on Dmap contract
  if(action == "sample-chosen")
  {
    //  CPU smart contract created/called to keep CPU audit trail
    //create and start CPU smart contract
    localthis.createComputecontract('setup-start-cpu', contractID);

  }
  else if(action == "cpu-contract-address")
  {
       //  record smart contract details
       mysamplingContract.setDsampling(contractID);
       // perform computation  extract github url from smart contract
       var getDmapdetails = mysamplingContract.getDmapDetail();
       var githuburl = getDmapdetails[2] + getDmapdetails[3] + getDmapdetails[4];
console.log(githuburl);
        var getGithubhash = mysamplingContract.getDmapDetailchash();
        var Githubhash = getGithubhash[0] + getGithubhash[1];
console.log(Githubhash);
        // get the datamode to identify sensor -> storage contract
        var datamodelRequired = mysamplingContract.getDataModel();
       // carry out the computation
       localthis.dmcomputeprotocol.startCompute('dsample-compute', contractID, githuburl, Githubhash, datamodelRequired, this);

       // select next node (emit message to get to DHT class) pass on the dmap contractID
       localthis.emit("sample-next", contractID);    //liveDHT.oneHop();


  }
  else if(action == "get-dmap-details")
  {
    // call the contract to return data
    var returnDmap = mysamplingContract.getMname();
console.log('Dmap ID =====');
console.log(returnDmap);
    // send back to UI

  }
  else if(action == "visualisation")
  {
    // get the storage and sensor details and proceed to visualisation
    // get the data and return to UI  HARDWIRES example wearable data for now
    localthis.dmcomputeprotocol.startCompute('visualisation-compute', contractID, this.liveInflux);

  }
  else if(action == "set-invite-peer")
  {
    // update contract to keep record of who has been invited
    //var  = mysamplingContract.setPeerInvite();
    // send message to Peer for them to pick up
    var peerInvitemessage = {};
    peerInvitemessage.type = 'Peer-invite';
    peerInvitemessage.text = 'researcherinvite';
    peerInvitemessage.scid = contractID;
    peerInvitemessage.pubethk = pubkeyeth;
    peerInvitemessage.pkasker = this.publicaccount;
    peerInvitemessage.data = ['activity', 'temperature'];
    var serialiseRmessage = JSON.stringify(peerInvitemessage);
    localthis.emit("permision-notify", serialiseRmessage);

  }
  else if(action == "set-ppathhash")
  {
    // prepare string max lenghts for solidty limits
    ppstr1 = ppath.slice(0,24);
    ppstr2 = ppath.slice(24,48);
    ppstr3 = ppath.slice(48,62);
    mysamplingContract.setPredpath(ppstr1, ppstr2, ppstr3);
  }
  else if(action == "record-scoring")
  {
    mysamplingContract.setDscoring(score);

  }


};

/**
*   recall data from CPU api smart contract
* @method recallCPUapiContract
*
*
*/
ethereurmjsAPI.prototype.recallCPUapiContract = function(action, contractID, pubkeyeth) {

  var localthis = this;
  var contractdata = this.readSolidityfile('cpuapi-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var keye = Object.keys(compiled);
  var code = compiled[keye[0]].code;
  // contract json abi, this is autogenerated using solc CLI
  var abi = compiled[keye[0]].info.abiDefinition;
  var myContract;
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(contractID);

  // what action required on Dmap contract
  if(action == "stop-compute")
  {
    // stop time from blockchain via smart contract
    mysamplingContract.setComputeStop(contractID);

  }

};

/**
*  listening to the EVM blockchain for new smart contracts
* @method listenforMPPM
*
*
*/
ethereurmjsAPI.prototype.listenforMPPM = function() {


};


module.exports = ethereurmjsAPI;
